<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>clock</title>
</head>
<body>
  <canvas id="canvas" width="800" height="800" style="border: 1px solid #ccc;"></canvas>
</body>
<script>
  const canvas = document.querySelector('#canvas')
  const ctx = canvas.getContext('2d')
  ctx.arc(400, 400, 200, 0, Math.PI * 2)
  // 这里为了防止arc与moveTo的坐标连接 所以将绘制起点移动到内圆的右坐标处（因为我们是从0角度开始画的）
  ctx.moveTo(580, 400)
  ctx.arc(400, 400, 180, 0, Math.PI * 2)
  ctx.stroke()
  /* 方法一 */ 
  // 秒针
  // ctx.moveTo(400, 400)
  // ctx.lineTo(400, 240)
  // ctx.stroke()
  // 分针
  // ctx.moveTo(400, 400)
  // ctx.lineTo(300, 400)
  // moveTo会对closePath产生影响 而不会对stroke方法影响 所以实际上只需在这里调用一次stroke即可
  // ctx.stroke()

  /* 方法二 将绘制点利用转换绘制 因为变换的影响是全局的 */ 
  // translate方法必须先放在移动坐标的代码之前 因为它是参考点 canvas中本身没有负坐标 (包括rotate，总结一句话， 变化需要放在坐标变更之前 而且可以叠加)
  ctx.translate(400, 400)
  ctx.moveTo(0, 0)
  ctx.lineTo(0, -160)
  ctx.moveTo(0, 0)
  ctx.lineTo(-120, 0)
  ctx.stroke()
  ctx.clearRect(-400, -400, 800, 800)
  // 秒针旋转 
  const angle = Math.PI * 2 / 60
  let i = 1
  // setInterval(() => {
  //   ctx.clearRect(-400, -400, 800, 800)
  //   ctx.rotate(angle)
  //   ctx.moveTo(0, 0)
  //   ctx.lineTo(0, -160)
  //   ctx.stroke()
  //   ctx.restore()
  //   i++
  //   console.log(angle, i)
  // }, 1000)
</script>
</html>